[{"path":"https://pharmaverse.github.io/sdtm.oak/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (http://contributor-covenant.org), version 1.0.0, available http://contributor-covenant.org/version/1/0/0/","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contribution to {sdtm.oak}","title":"Contribution to {sdtm.oak}","text":"outlines propose change sdtm.oak package. detailed info contributing {sdtm.oak}, pharmaverse packages, please see Contribution Guide well Developer Guides Articles section {admiraldev} website. Please note try align best practices used R packages’ development processes - veteran developers familiar processes. However, deviate slightly best practices advise new contributors review package documentation accordingly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/CONTRIBUTING.html","id":"basics","dir":"","previous_headings":"","what":"Basics","title":"Contribution to {sdtm.oak}","text":"new contribution, user creates issue issue tab GitHub put backlog. issues can range bug identification /fixes, enhancements functions, documentation, tests new features. advise contact us issue created via Slack (don’t access, use link join). can discuss details align expectations familiar sdtm.oak philosophy programming strategy. team try review issues within next backlog meeting give initial feedback. Since 100% fully resourced software development team might issues take longer respond depending amount overall issues.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright [yyyy] [name of copyright owner]  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/algorithms.html","id":"core-concept","dir":"Articles","previous_headings":"","what":"Core Concept","title":"Algorithms & Sub-Algorithms","text":"SDTM mappings defined algorithms transform collected (eCRF, eDT) source data target SDTM data model. Mapping algorithms backbone sdtm.oak - SDTM data transformation engine. Key Points: Algorithms can re-used across multiple SDTM domains. Algorithms pre-specified data collection standards MDR (applicable) Programming language agnostic - concept rely specific programming language implementation. OAK team implemented R functions. example reusing algorithm across multiple domains, variables, also non-standard","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/algorithms.html","id":"sub-algorithms","dir":"Articles","previous_headings":"","what":"Sub-algorithms","title":"Algorithms & Sub-Algorithms","text":"sdtm.oak supports two levels defining algorithms. example, SDTM mappings certain action taken condition met. cases, primary algorithm checks condition, sub-algorithm executes mappings condition met. Currently, sub-algorithms must provided main algorithms. IF_THEN_ELSE DATASET_LEVEL Algorithms can interchangeably used algorithms sub-algorithms seen (exhaustive list)  permutation & combination algorithms & sub-algorithms creates endless possibilities accommodate different types mappings.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Converting dates, times or date-times to ISO 8601","text":"perform conversion ISO 8601 format need pass two key arguments: least one vector dates, times, date-times character type; date/time format via .format parameter instructs create_iso8601() date/time components expect. default .format parameter understands reserved characters: \"y\" year \"m\" month \"d\" day \"H\" hours \"M\" minutes \"S\" seconds Besides character vectors dates times, may also pass single vector date-times, provided adjust format:","code":"create_iso8601(\"2000 01 05\", .format = \"y m d\") #> [1] \"2000-01-05\" create_iso8601(\"22:35:05\", .format = \"H:M:S\") #> [1] \"-----T22:35:05\" create_iso8601(\"2000-01-05 22:35:05\", .format = \"y-m-d H:M:S\") #> [1] \"2000-01-05T22:35:05\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"multiple-inputs","dir":"Articles","previous_headings":"","what":"Multiple inputs","title":"Converting dates, times or date-times to ISO 8601","text":"dates times separate vectors need pass format vector: addition, like R functions take vectors input, create_iso8601() vectorized: number elements inputs match get error: can combine individual date time components coming separate inputs; contrived example year, month day together, hour, minute: .format argument must always named; otherwise, treated one inputs interpreted missing.","code":"create_iso8601(\"2000-01-05\", \"22:35:05\", .format = c(\"y-m-d\", \"H:M:S\")) #> [1] \"2000-01-05T22:35:05\" date <- c(\"2000-01-05\", \"2001-12-25\", \"1980-06-18\", \"1979-09-07\") time <- c(\"00:12:21\", \"22:35:05\", \"03:00:15\", \"07:09:00\") create_iso8601(date, time, .format = c(\"y-m-d\", \"H:M:S\")) #> [1] \"2000-01-05T00:12:21\" \"2001-12-25T22:35:05\" \"1980-06-18T03:00:15\" #> [4] \"1979-09-07T07:09:00\" date <- c(\"2000-01-05\", \"2001-12-25\", \"1980-06-18\", \"1979-09-07\") time <- \"00:12:21\" try(create_iso8601(date, time, .format = c(\"y-m-d\", \"H:M:S\"))) #> Error in create_iso8601(date, time, .format = c(\"y-m-d\", \"H:M:S\")) :  #>   All vectors in `...` must be of the same length. year <- c(\"99\", \"84\", \"00\", \"80\", \"79\", \"1944\", \"1953\") month_and_day <- c(\"jan 1\", \"apr 04\", \"mar 06\", \"jun 18\", \"sep 07\", \"sep 13\", \"sep 14\") hour <- c(\"12\", \"13\", \"05\", \"23\", \"16\", \"16\", \"19\") min <- c(\"0\", \"60\", \"59\", \"42\", \"44\", \"10\", \"13\") create_iso8601(year, month_and_day, hour, min, .format = c(\"y\", \"m d\", \"H\", \"M\")) #> [1] \"1999-01-01T12:00\" \"1984-04-04T13:60\" \"2000-03-06T05:59\" \"1980-06-18T23:42\" #> [5] \"1979-09-07T16:44\" \"1944-09-13T16:10\" \"1953-09-14T19:13\" try(create_iso8601(\"2000-01-05\", \"y-m-d\")) #> Error in create_iso8601(\"2000-01-05\", \"y-m-d\") :  #>   argument \".format\" is missing, with no default"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"format-variations","dir":"Articles","previous_headings":"","what":"Format variations","title":"Converting dates, times or date-times to ISO 8601","text":".format parameter can easily accommodate variations format inputs: Individual components may come different order, adjust format accordingly: individual characters given format taken strictly, e.g. number spaces matters: format can include regular expressions though: default, streak reserved characters treated one provided, formats equivalent:","code":"create_iso8601(\"2000-01-05\", .format = \"y-m-d\") #> [1] \"2000-01-05\" create_iso8601(\"2000 01 05\", .format = \"y m d\") #> [1] \"2000-01-05\" create_iso8601(\"2000/01/05\", .format = \"y/m/d\") #> [1] \"2000-01-05\" create_iso8601(\"2000 01 05\", .format = \"y m d\") #> [1] \"2000-01-05\" create_iso8601(\"05 01 2000\", .format = \"d m y\") #> [1] \"2000-01-05\" create_iso8601(\"01 05, 2000\", .format = \"m d, y\") #> [1] \"2000-01-05\" date <- c(\"2000 01 05\", \"2000  01 05\", \"2000 01  05\", \"2000   01   05\") create_iso8601(date, .format = \"y m d\") #> [1] \"2000-01-05\" NA           NA           NA create_iso8601(date, .format = \"y  m d\") #> [1] NA           \"2000-01-05\" NA           NA create_iso8601(date, .format = \"y m  d\") #> [1] NA           NA           \"2000-01-05\" NA create_iso8601(date, .format = \"y   m   d\") #> [1] NA           NA           NA           \"2000-01-05\" create_iso8601(date, .format = \"y\\\\s+m\\\\s+d\") #> [1] \"2000-01-05\" \"2000-01-05\" \"2000-01-05\" \"2000-01-05\" date <- c(\"2000-01-05\", \"2001-12-25\", \"1980-06-18\", \"1979-09-07\") time <- c(\"00:12:21\", \"22:35:05\", \"03:00:15\", \"07:09:00\") create_iso8601(date, time, .format = c(\"y-m-d\", \"H:M:S\")) #> [1] \"2000-01-05T00:12:21\" \"2001-12-25T22:35:05\" \"1980-06-18T03:00:15\" #> [4] \"1979-09-07T07:09:00\" create_iso8601(date, time, .format = c(\"yyyy-mm-dd\", \"HH:MM:SS\")) #> [1] \"2000-01-05T00:12:21\" \"2001-12-25T22:35:05\" \"1980-06-18T03:00:15\" #> [4] \"1979-09-07T07:09:00\" create_iso8601(date, time, .format = c(\"yyyyyyyy-m-dddddd\", \"H:MMMMM:SSSS\")) #> [1] \"2000-01-05T00:12:21\" \"2001-12-25T22:35:05\" \"1980-06-18T03:00:15\" #> [4] \"1979-09-07T07:09:00\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"multiple-alternative-formats","dir":"Articles","previous_headings":"","what":"Multiple alternative formats","title":"Converting dates, times or date-times to ISO 8601","text":"input vector contains values varying formats, single format may adequate encompass variations. situations, ’s advisable list multiple alternative formats. approach ensures format tried sequentially one matches data vector. Consider order supply formats, can significant. multiple formats potentially match, sequence determines format applied first. Note passing alternative formats, .format argument must list whose length matches number inputs.","code":"date <- c(\"2000/01/01\", \"2000-01-02\", \"2000 01 03\", \"2000/01/04\") create_iso8601(date, .format = \"y-m-d\") #> [1] NA           \"2000-01-02\" NA           NA create_iso8601(date, .format = \"y m d\") #> [1] NA           NA           \"2000-01-03\" NA create_iso8601(date, .format = \"y/m/d\") #> [1] \"2000-01-01\" NA           NA           \"2000-01-04\" create_iso8601(date, .format = list(c(\"y-m-d\", \"y m d\", \"y/m/d\"))) #> [1] \"2000-01-01\" \"2000-01-02\" \"2000-01-03\" \"2000-01-04\" create_iso8601(\"07 04 2000\", .format = list(c(\"d m y\", \"m d y\"))) #> [1] \"2000-04-07\" create_iso8601(\"07 04 2000\", .format = list(c(\"m d y\", \"d m y\"))) #> [1] \"2000-07-04\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"parsing-of-date-or-time-components","dir":"Articles","previous_headings":"","what":"Parsing of date or time components","title":"Converting dates, times or date-times to ISO 8601","text":"default, date time components parsed follows: year: either parsed two- four-digit year; month: either numeric month (single two-digit number) English abbreviated month name (e.g. Jan, Jun Dec) regardless case; month day: parsed two-digit numbers; hour minute: parsed single two-digit numbers; second: parsed single two-digit numbers optional fractional part.","code":"# Years: two-digit or four-digit numbers. years <- c(\"0\", \"1\", \"00\", \"01\", \"15\", \"30\", \"50\", \"68\", \"69\", \"80\", \"99\") create_iso8601(years, .format = \"y\") #>  [1] NA     NA     \"2000\" \"2001\" \"2015\" \"2030\" \"2050\" \"2068\" \"1969\" \"1980\" #> [11] \"1999\"  # Adjust the point where two-digits years are mapped to 2000's or 1900's. create_iso8601(years, .format = \"y\", .cutoff_2000 = 20L) #>  [1] NA     NA     \"2000\" \"2001\" \"2015\" \"1930\" \"1950\" \"1968\" \"1969\" \"1980\" #> [11] \"1999\"  # Both numeric months (two-digit only) and abbreviated months work out of the box months <- c(\"0\", \"00\", \"1\", \"01\", \"Jan\", \"jan\") create_iso8601(months, .format = \"m\") #> [1] NA     \"--00\" NA     \"--01\" \"--01\" \"--01\"  # Month days: single or two-digit numbers, anything else results in NA. create_iso8601(c(\"1\", \"01\", \"001\", \"10\", \"20\", \"31\"), .format = \"d\") #> [1] \"----01\" \"----01\" NA       \"----10\" \"----20\" \"----31\"  # Hours create_iso8601(c(\"1\", \"01\", \"001\", \"10\", \"20\", \"31\"), .format = \"H\") #> [1] \"-----T01\" \"-----T01\" NA         \"-----T10\" \"-----T20\" \"-----T31\"  # Minutes create_iso8601(c(\"1\", \"01\", \"001\", \"10\", \"20\", \"60\"), .format = \"M\") #> [1] \"-----T-:01\" \"-----T-:01\" NA           \"-----T-:10\" \"-----T-:20\" #> [6] \"-----T-:60\"  # Seconds create_iso8601(c(\"1\", \"01\", \"23.04\", \"001\", \"10\", \"20\", \"60\"), .format = \"S\") #> [1] \"-----T-:-:01\"    \"-----T-:-:01\"    \"-----T-:-:23.04\" NA                #> [5] \"-----T-:-:10\"    \"-----T-:-:20\"    \"-----T-:-:60\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"allowing-alternative-date-or-time-values","dir":"Articles","previous_headings":"","what":"Allowing alternative date or time values","title":"Converting dates, times or date-times to ISO 8601","text":"date time component values include special values, e.g. values encoding missing values, can indicate values possible alternatives parsing tolerate ; use .na argument: case achieve result using regexps:","code":"create_iso8601(\"U DEC 2019 14:00\", .format = \"d m y H:M\") #> [1] NA create_iso8601(\"U DEC 2019 14:00\", .format = \"d m y H:M\", .na = \"U\") #> [1] \"2019-12--T14:00\"  create_iso8601(\"U UNK 2019 14:00\", .format = \"d m y H:M\") #> [1] NA create_iso8601(\"U UNK 2019 14:00\", .format = \"d m y H:M\", .na = c(\"U\", \"UNK\")) #> [1] \"2019----T14:00\" create_iso8601(\"U UNK 2019 14:00\", .format = \"(d|U) (m|UNK) y H:M\") #> [1] \"2019----T14:00\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"changing-reserved-format-characters","dir":"Articles","previous_headings":"","what":"Changing reserved format characters","title":"Converting dates, times or date-times to ISO 8601","text":"might cases reserved characters — \"y\", \"m\", \"d\", \"H\", \"M\", \"S\" — might get way specifying adequate format. example, might tempted use format \"HHMM\" try parse time \"14H00M\". assume first “H” codes parsing hour, second “H” literal “H” , actually, \"HH\" taken mean parsing hours, \"MM\" parse minutes. can use function fmt_cmp() specify alternative format regexps format, replacing default characters. next example, reassign new format strings hour minute components, thus freeing \"H\" \"M\" patterns interpreted hours minutes, taken literally: Note need make sure format component regexps mutually exclusive, .e. don’t overlapping matches; otherwise create_iso8601() fail error. next example months minutes represented \"m\" format resulting ambiguous format specification.","code":"create_iso8601(\"14H00M\", .format = \"HHMM\") #> [1] NA create_iso8601(\"14H00M\", .format = \"xHwM\", .fmt_c = fmt_cmp(hour = \"x\", min = \"w\")) #> [1] \"-----T14:00\" fmt_cmp(hour = \"h\", min = \"m\") #> $sec #> [1] \"S+\" #>  #> $min #> [1] \"m\" #>  #> $hour #> [1] \"h\" #>  #> $mday #> [1] \"d+\" #>  #> $mon #> [1] \"m+\" #>  #> $year #> [1] \"y+\" #>  #> attr(,\"class\") #> [1] \"fmt_c\" try(create_iso8601(\"14H00M\", .format = \"hHmM\", .fmt_c = fmt_cmp(hour = \"h\", min = \"m\"))) #> Error in purrr::map2(dots, .format, ~parse_dttm(dttm = .x, fmt = .y, na = .na,  :  #>   ℹ In index: 1. #> Caused by error in `purrr::map()` at sdtm.oak/R/dtc_parse_dttm.R:104:3: #> ℹ In index: 1. #> Caused by error in `parse_dttm_fmt()` at sdtm.oak/R/parse_dttm_fmt.R:442:3: #> ! Patterns in `fmt_c` have overlapping matches."},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/study_sdtm_spec.html","id":"standards-metadata","dir":"Articles","previous_headings":"","what":"Standards Metadata","title":"All about Metadata","text":"standards metadata used {sdtm.oak} sourced CDISC Library sponsor MDR form documentation standards maintained. metadata provides information following: relationship Data Collection Standards (eCRF & eDT), SDTM mapping, Controlled Terminology Machine-readable standard SDTM mappings Algorithms associated metadata required SDTM automation standards study. upcoming releases {sdtm.oak}, effectively utilize standards metadata customize meet study requirements.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/study_sdtm_spec.html","id":"study-definition-metadata","dir":"Articles","previous_headings":"","what":"Study Definition Metadata","title":"All about Metadata","text":"Study Definition Metadata also referred Study Metadata. Study Definition Metadata provides information eCRF eDT data collected study. eCRF Metadata eCRF Design Metadata fetched EDC system. Metadata includes Forms Metadata: Identifier, eCRF label, Repeating format properties eCRF. Fields Metadata: Identifier, question label, datatype, properties data collection fields study. Data Dictionaries: Identifier controlled terms collected source. Visits: Name visits defined EDC. eDT Metadata eDT Metadata blueprint metadata describes data collected part external data transfer (clinical sites sponsor). includes Dataset name, label, repeating properties, etc. Variable name, datatype, label associated codelist, etc.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/study_sdtm_spec.html","id":"study-sdtm-mappings-metadata-specifications","dir":"Articles","previous_headings":"","what":"Study SDTM Mappings Metadata (specifications)","title":"All about Metadata","text":"Study SDTM mappings metadata study SDTM specification. develop SDTM domains, {sdtm.oak} requires user prepare Study SDTM mappings metadata. Unlike conventional SDTM specification, includes one tab per domain defining target (SDTM domain, Variables) source (raw dataset, raw variables) SDTM mappings, SDTM spec {sdtm.oak} defines source--target relationship. source, SDTM mapping, algorithms, associated metadata defined. table presents columns SDTM mapping specification explanation.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rammprasad Ganapathy. Author, maintainer. Adam Forys. Author. Edgar Manukyan. Author. Rosemary Li. Author. Preetesh Parikh. Author. Lisa Houterloot. Author. Yogesh Gupta. Author. Omar Garcia. Author. Ramiro Magno. Author. Pattern Institute. Copyright holder, funder. F. Hoffmann-La Roche AG. Copyright holder, funder. Pfizer Inc. Copyright holder, funder.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ganapathy R, Forys , Manukyan E, Li R, Parikh P, Houterloot L, Gupta Y, Garcia O, Magno R (2024). sdtm.oak: SDTM Data Transformation Engine. R package version 0.0.0.9001, https://github.com/pharmaverse/sdtm.oak, https://pharmaverse.github.io/sdtm.oak/.","code":"@Manual{,   title = {sdtm.oak: SDTM Data Transformation Engine},   author = {Rammprasad Ganapathy and Adam Forys and Edgar Manukyan and Rosemary Li and Preetesh Parikh and Lisa Houterloot and Yogesh Gupta and Omar Garcia and Ramiro Magno},   year = {2024},   note = {R package version 0.0.0.9001, https://github.com/pharmaverse/sdtm.oak},   url = {https://pharmaverse.github.io/sdtm.oak/}, }"},{"path":"https://pharmaverse.github.io/sdtm.oak/index.html","id":"sdtmoak-","dir":"","previous_headings":"","what":"SDTM Data Transformation Engine","title":"SDTM Data Transformation Engine","text":"EDC Data Standard agnostic solution enables pharmaceutical programming community develop SDTM datasets R. reusable algorithms concept sdtm.oak provides framework modular programming also can automate SDTM creation based standard SDTM spec.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"SDTM Data Transformation Engine","text":"can install development version sdtm.oak GitHub :","code":"# install.packages(\"remotes\") remotes::install_github(\"pharmaverse/sdtm.oak\")"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":null,"dir":"Reference","previous_headings":"","what":"Add ISO 8601 parsing problems — add_problems","title":"Add ISO 8601 parsing problems — add_problems","text":"add_problems() annotates returned value create_iso8601() possible parsing problems. annotation consists tibble problems, one row parsing failure (see Details section).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add ISO 8601 parsing problems — add_problems","text":"","code":"add_problems(x, is_problem, dtc)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add ISO 8601 parsing problems — add_problems","text":"x character vector date-times ISO 8601 format; typically, output format_iso8601(). is_problem logical indicating date/time inputs associated parsing failures. dtc list character vectors dates, times date-times' components. Typically, parameter takes value passed ... create_iso8601() call.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add ISO 8601 parsing problems — add_problems","text":"Either x without modification, parsing problems exist, annotated x, meaning problems attribute holds parsing issues (see Details section).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add ISO 8601 parsing problems — add_problems","text":"function annotates input x, vector date-times ISO 8601 format, creating attribute named problems. attribute's value tibble parsing problems. problematic date/times indicated logical vector passed argument is_problem. attribute problems returned value contain first column named ..indicates date/time index problematic date/time x, many extra columns inputs (passed dtc). dtc named, names used name extra columns, otherwise get named sequentially like ..var1, ..var2, etc..","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add ISO 8601 parsing problems — add_problems","text":"","code":"date <- c(\"2000-01-05\", \"\", \"1980-06-18\", \"1979-09-07\") time <- c(\"001221\", \"22:35:05\", \"03:00:15\", \"07:09:00\") dtc <- list(date, time) dttm <- c(\"2000-01-05\", \"T22:35:05\", \"1980-06-18T03:00:15\", \"1979-09-07T07:09:00\") is_problem <- c(TRUE, TRUE, FALSE, FALSE)  dttm2 <- sdtm.oak:::add_problems(dttm, is_problem, dtc) sdtm.oak:::problems(dttm2) #> # A tibble: 2 × 3 #>     ..i ..var1       ..var2   #>   <int> <chr>        <chr>    #> 1     1 \"2000-01-05\" 001221   #> 2     2 \"\"           22:35:05"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/any_problems.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect problems with the parsing of date/times — any_problems","title":"Detect problems with the parsing of date/times — any_problems","text":"any_problems() takes list capture matrices (see parse_dttm()) reports parsing problems means predicate values. FALSE value indicates parsing successful TRUE value parsing failure least one inputs create_iso8601(). Note internal function used context create_iso8601() source code hence capture matrix corresponds one input create_iso8601().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/any_problems.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect problems with the parsing of date/times — any_problems","text":"","code":"any_problems(cap_matrices, .cutoff_2000 = 68L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/any_problems.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect problems with the parsing of date/times — any_problems","text":"cap_matrices list capture matrices sense returned value parse_dttm(). .cutoff_2000 integer value. Two-digit years smaller equal .cutoff_2000 parsed though starting 20, otherwise parsed though starting 19.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/any_problems.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect problems with the parsing of date/times — any_problems","text":"logical whose length matches number underlying date/times passed inputs create_iso8601(), .e. whose length matches number rows capture matrices cap_matrices.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/any_problems.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect problems with the parsing of date/times — any_problems","text":"","code":"# No problem (return value is `FALSE`). sdtm.oak:::any_problems(list(sdtm.oak:::parse_dttm(\"1980-06-18\", \"y-m-d\"))) #> [1] FALSE  # Now the parsing fails (return value is `TRUE`). sdtm.oak:::any_problems(list(sdtm.oak:::parse_dttm(\"1980-06-18\", \"ymd\"))) #> [1] TRUE  # Find if there has been a problem in either in the `date` or `time` inputs. # The following problems are expected with: #   - `\"2001/12/25\"` as it won't be parsed with the format `\"y-m-d\"` #   - `\"00h12m21\"` as it won't be parsed with the format `\"H:M:S\"`. # date <- c(\"2000-01-05\", \"2001/12/25\", \"1980-06-18\", \"1979-09-07\") time <- c(\"00h12m21\", \"22:35:05\", \"03:00:15\", \"07:09:00\")  cap_matrix_date <- sdtm.oak:::parse_dttm(date, \"y-m-d\") cap_matrix_time <- sdtm.oak:::parse_dttm(time, \"H:M:S\")  (cap_matrices <- list(cap_matrix_date, cap_matrix_time)) #> [[1]] #>      year   mon  mday hour min sec #> [1,] \"2000\" \"01\" \"05\" NA   NA  NA  #> [2,] NA     NA   NA   NA   NA  NA  #> [3,] \"1980\" \"06\" \"18\" NA   NA  NA  #> [4,] \"1979\" \"09\" \"07\" NA   NA  NA  #>  #> [[2]] #>      year mon mday hour min  sec  #> [1,] NA   NA  NA   NA   NA   NA   #> [2,] NA   NA  NA   \"22\" \"35\" \"05\" #> [3,] NA   NA  NA   \"03\" \"00\" \"15\" #> [4,] NA   NA  NA   \"07\" \"09\" \"00\" #>   # `any_problems()` returns `TRUE` for the first two elements because of the # failure to parse `\"2001/12/25\"` and `\"00h12m21\"`, respectively. sdtm.oak:::any_problems(cap_matrices) #> [1]  TRUE  TRUE FALSE FALSE"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_capture_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert capture matrix — assert_capture_matrix","title":"Assert capture matrix — assert_capture_matrix","text":"assert_capture_matrix() internal helper function aiding checking internal R object contains parsing results returned parse_dttm(): capture matrix. function checks capture matrix matrix contains six columns: year, mon, mday, hour, min sec.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_capture_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert capture matrix — assert_capture_matrix","text":"","code":"assert_capture_matrix(m)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_capture_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert capture matrix — assert_capture_matrix","text":"m character matrix.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_capture_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert capture matrix — assert_capture_matrix","text":"function throws error m either: character matrix; matrix whose columns (least): year, mon, mday, hour, min sec. Otherwise, returns m invisibly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_capture_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert capture matrix — assert_capture_matrix","text":"","code":"cols <- c(\"year\", \"mon\", \"mday\", \"hour\", \"min\", \"sec\") m <- matrix(NA_character_, nrow = 1L, ncol = 6L, dimnames = list(NULL, cols)) sdtm.oak:::assert_capture_matrix(m)  # These commands should throw an error if (FALSE) {   sdtm.oak:::assert_capture_matrix(character())   sdtm.oak:::assert_capture_matrix(matrix(data = NA_character_, nrow = 0, ncol = 0))   sdtm.oak:::assert_capture_matrix(matrix(data = NA_character_, nrow = 1)) }"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_fmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert date time character formats — assert_dtc_fmt","title":"Assert date time character formats — assert_dtc_fmt","text":"assert_dtc_fmt() takes character vector date/time formats checks formats supported, meaning checks one formats listed column fmt dtc_formats, failing error otherwise.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_fmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert date time character formats — assert_dtc_fmt","text":"","code":"assert_dtc_fmt(fmt)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_fmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert date time character formats — assert_dtc_fmt","text":"fmt character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_fmt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert date time character formats — assert_dtc_fmt","text":"","code":"sdtm.oak:::assert_dtc_fmt(c(\"ymd\", \"y m d\", \"dmy\", \"HM\", \"H:M:S\", \"y-m-d H:M:S\")) #> [1] \"ymd\"         \"y m d\"       \"dmy\"         \"HM\"          \"H:M:S\"       #> [6] \"y-m-d H:M:S\"  # This example is guarded to avoid throwing errors if (FALSE) {   sdtm.oak:::assert_dtc_fmt(\"y years m months d days\") }"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_format.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert dtc format — assert_dtc_format","title":"Assert dtc format — assert_dtc_format","text":"assert_dtc_format() internal helper function aiding checking .format parameter create_iso8601().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert dtc format — assert_dtc_format","text":"","code":"assert_dtc_format(.format)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert dtc format — assert_dtc_format","text":".format argument create_iso8601()'s .format parameter.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert dtc format — assert_dtc_format","text":"function throws error .format either: character vector formats permitted assert_dtc_fmt(); list character vectors formats permitted assert_dtc_fmt(). Otherwise, returns .format invisibly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert dtc format — assert_dtc_format","text":"","code":"sdtm.oak:::assert_dtc_format(\"ymd\") sdtm.oak:::assert_dtc_format(c(\"ymd\", \"y-m-d\")) sdtm.oak:::assert_dtc_format(list(c(\"ymd\", \"y-m-d\"), \"H:M:S\"))  # These commands should throw an error if (FALSE) {   # Note that `\"year, month, day\"` is not a supported format.   sdtm.oak:::assert_dtc_format(\"year, month, day\") }"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/coalesce_capture_matrices.html","id":null,"dir":"Reference","previous_headings":"","what":"Coalesce capture matrices — coalesce_capture_matrices","title":"Coalesce capture matrices — coalesce_capture_matrices","text":"coalesce_capture_matrices() combines several capture matrices one. argument ... capture matrix sense output complete_capture_matrix(), meaning character matrix six columns whose names : year, mon, mday, hour, min sec.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/coalesce_capture_matrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coalesce capture matrices — coalesce_capture_matrices","text":"","code":"coalesce_capture_matrices(...)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/coalesce_capture_matrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coalesce capture matrices — coalesce_capture_matrices","text":"... sequence capture matrices.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/coalesce_capture_matrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coalesce capture matrices — coalesce_capture_matrices","text":"single capture matrix whose values coalesced sense coalesce().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/coalesce_capture_matrices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coalesce capture matrices — coalesce_capture_matrices","text":"","code":"cols <- c(\"year\", \"mon\", \"mday\", \"hour\", \"min\", \"sec\") dates <- c(\"2020\", \"01\", \"01\", \"20\", NA, NA) times <- c(NA, NA, NA, \"10\", \"00\", \"05\") m_dates <- matrix(dates, nrow = 1L, ncol = 6L, dimnames = list(NULL, cols)) m_times <- matrix(times, nrow = 1L, ncol = 6L, dimnames = list(NULL, cols))  # Note how the hour \"20\" takes precedence over \"10\" sdtm.oak:::coalesce_capture_matrices(m_dates, m_times) #>      year   mon  mday hour min  sec  #> [1,] \"2020\" \"01\" \"01\" \"20\" \"00\" \"05\"  # Reverse the order of the inputs and now hour \"10\" takes precedence sdtm.oak:::coalesce_capture_matrices(m_times, m_dates) #>      year   mon  mday hour min  sec  #> [1,] \"2020\" \"01\" \"01\" \"10\" \"00\" \"05\"  # Single inputs should result in the same output as the input sdtm.oak:::coalesce_capture_matrices(m_dates) #>      year   mon  mday hour min sec #> [1,] \"2020\" \"01\" \"01\" \"20\" NA  NA  sdtm.oak:::coalesce_capture_matrices(m_times) #>      year mon mday hour min  sec  #> [1,] NA   NA  NA   \"10\" \"00\" \"05\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/complete_capture_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete a capture matrix — complete_capture_matrix","title":"Complete a capture matrix — complete_capture_matrix","text":"complete_capture_matrix() completes missing, , columns capture matrix.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/complete_capture_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete a capture matrix — complete_capture_matrix","text":"","code":"complete_capture_matrix(m)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/complete_capture_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Complete a capture matrix — complete_capture_matrix","text":"m character matrix might missing one following columns: year, mon, mday, hour, min sec.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/complete_capture_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Complete a capture matrix — complete_capture_matrix","text":"character matrix contains columns year, mon, mday, hour, min sec. existing columns dropped.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/complete_capture_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Complete a capture matrix — complete_capture_matrix","text":"","code":"sdtm.oak:::complete_capture_matrix(matrix(data = NA_character_, nrow = 0, ncol = 0)) sdtm.oak:::complete_capture_matrix(matrix(data = NA_character_, nrow = 1))  # m <- matrix(NA_character_, nrow = 1, ncol = 2, dimnames = list(NULL, c(\"year\", \"sec\"))) # sdtm.oak:::complete_capture_matrix(m)  # m <- matrix(c(\"2020\", \"10\"), nrow = 1, ncol = 2, dimnames = list(NULL, c(\"year\", \"sec\"))) # sdtm.oak:::complete_capture_matrix(m)  # Any other existing columns are dropped. # m <- matrix(c(\"2020\", \"10\"), nrow = 1, ncol = 2, dimnames = list(NULL, c(\"semester\", \"quarter\"))) # sdtm.oak:::complete_capture_matrix(m)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/create_iso8601.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert date or time collected values to ISO 8601 — create_iso8601","title":"Convert date or time collected values to ISO 8601 — create_iso8601","text":"create_iso8601() converts vectors dates, times date-times ISO 8601 format. Learn vignette(\"iso_8601\").","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/create_iso8601.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert date or time collected values to ISO 8601 — create_iso8601","text":"","code":"create_iso8601(   ...,   .format,   .fmt_c = fmt_cmp(),   .na = NULL,   .cutoff_2000 = 68L,   .check_format = FALSE,   .warn = TRUE )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/create_iso8601.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert date or time collected values to ISO 8601 — create_iso8601","text":"... Character vectors dates, times date-times' components. .format Parsing format(s). Either character vector list character vectors. character vector passed element taken parsing format vector passed .... list provided, element must character vector formats. first vector formats used parsing first vector passed ..., . .fmt_c list regexps use parsing .format. Use fmt_cmp() create object pass argument parameter. .na character vector string literals regarded missing values parsing. .cutoff_2000 integer value. Two-digit years smaller equal .cutoff_2000 parsed though starting 20, otherwise parsed though starting 19. .check_format Whether check formats passed .format, meaning check selection validated formats dtc_formats; permissible interpretation formats. .warn Whether warn parsing failures.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/create_iso8601.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert date or time collected values to ISO 8601 — create_iso8601","text":"","code":"# Converting dates create_iso8601(c(\"2020-01-01\", \"20200102\"), .format = \"y-m-d\") #> [1] \"2020-01-01\" NA           create_iso8601(c(\"2020-01-01\", \"20200102\"), .format = \"ymd\") #> [1] NA           \"2020-01-02\" create_iso8601(c(\"2020-01-01\", \"20200102\"), .format = list(c(\"y-m-d\", \"ymd\"))) #> [1] \"2020-01-01\" \"2020-01-02\"  # Two-digit years are supported create_iso8601(c(\"20-01-01\", \"200101\"), .format = list(c(\"y-m-d\", \"ymd\"))) #> [1] \"2020-01-01\" \"2020-01-01\"  # `.cutoff_2000` sets the cutoff for two-digit to four-digit year conversion # Default is at 68. create_iso8601(c(\"67-01-01\", \"68-01-01\", \"69-01-01\"), .format = \"y-m-d\") #> [1] \"2067-01-01\" \"2068-01-01\" \"1969-01-01\"  # Change it to 80. create_iso8601(c(\"79-01-01\", \"80-01-01\", \"81-01-01\"), .format = \"y-m-d\", .cutoff_2000 = 80) #> [1] \"2079-01-01\" \"2080-01-01\" \"1981-01-01\"  # Converting times create_iso8601(\"15:10\", .format = \"HH:MM\") #> [1] \"-----T15:10\" create_iso8601(\"2:10\", .format = \"HH:MM\") #> [1] \"-----T02:10\" create_iso8601(\"2:1\", .format = \"HH:MM\") #> [1] \"-----T02:01\" create_iso8601(\"02:01:56\", .format = \"HH:MM:SS\") #> [1] \"-----T02:01:56\" create_iso8601(\"020156.5\", .format = \"HHMMSS\") #> [1] \"-----T02:01:56.5\"  # Converting date-times create_iso8601(\"12 NOV 202015:15\", .format = \"dd mmm yyyyHH:MM\") #> [1] \"2020-11-12T15:15\"  # Indicate allowed missing values to make the parsing pass create_iso8601(\"U DEC 201914:00\", .format = \"dd mmm yyyyHH:MM\") #> [1] NA create_iso8601(\"U DEC 201914:00\", .format = \"dd mmm yyyyHH:MM\", .na = \"U\") #> [1] \"2019-12--T14:00\"  create_iso8601(\"NOV 2020\", .format = \"m y\") #> [1] \"2020-11\" create_iso8601(c(\"MAR 2019\", \"MaR 2020\", \"mar 2021\"), .format = \"m y\") #> [1] \"2019-03\" \"2020-03\" \"2021-03\"  create_iso8601(\"2019-04-041045-\", .format = \"yyyy-mm-ddHHMM-\") #> [1] \"2019-04-04T10:45\"  create_iso8601(\"20200507null\", .format = \"ymd(HH:MM:SS)\") #> [1] NA create_iso8601(\"20200507null\", .format = \"ymd((HH:MM:SS)|null)\") #> [1] \"2020-05-07\"  # Fractional seconds create_iso8601(\"2019-120602:20:13.1230001\", .format = \"y-mdH:M:S\") #> [1] \"2019-12-06T02:20:13.1230001\"  # Use different reserved characters in the format specification # Here we change \"H\" to \"x\" and \"M\" to \"w\", for hour and minute, respectively. create_iso8601(\"14H00M\", .format = \"HHMM\") #> [1] NA create_iso8601(\"14H00M\", .format = \"xHwM\", .fmt_c = fmt_cmp(hour = \"x\", min = \"w\")) #> [1] \"-----T14:00\"  # Alternative formats with unknown values datetimes <- c(\"UN UNK 201914:00\", \"UN JAN 2021\") format <- list(c(\"dd mmm yyyy\", \"dd mmm yyyyHH:MM\")) create_iso8601(datetimes, .format = format, .na = c(\"UN\", \"UNK\")) #> [1] \"2019----T14:00\" \"2021-01\"         # Dates and times may come in many format variations fmt <- \"dd MMM yyyy HH nn ss\" fmt_cmp <- fmt_cmp(mon = \"MMM\", min = \"nn\", sec = \"ss\") create_iso8601(\"05 feb 1985 12 55 02\", .format = fmt, .fmt_c = fmt_cmp) #> [1] \"1985-02-05T12:55:02\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":null,"dir":"Reference","previous_headings":"","what":"derive_study_day performs study day calculation — derive_study_day","title":"derive_study_day performs study day calculation — derive_study_day","text":"function takes input data frame reference data frame (DM domain cases), calculate study day reference date target date. case unexpected conditions like reference date unique patient, reference input dates actual dates, NA returned records.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"derive_study_day performs study day calculation — derive_study_day","text":"","code":"derive_study_day(   sdtm_in,   dm_domain,   tgdt,   refdt,   study_day_var,   merge_key = \"USUBJID\" )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"derive_study_day performs study day calculation — derive_study_day","text":"sdtm_in Input data frame contains target date. dm_domain Reference date frame contains reference date. tgdt Target date sdtm_in used calculate study day. refdt Reference date dm_domain used reference calculate study day. study_day_var New study day variable name output. example, AESTDY AE domain CMSTDY CM domain. merge_key Character represent merging key sdtm_in dm_domain.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"derive_study_day performs study day calculation — derive_study_day","text":"Data frame takes columns sdtm_in new variable represent calculated study day.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"derive_study_day performs study day calculation — derive_study_day","text":"","code":"ae <- data.frame(   USUBJID = c(\"study123-123\", \"study123-124\", \"study123-125\"),   AESTDTC = c(\"2012-01-01\", \"2012-04-14\", \"2012-04-14\") ) dm <- data.frame(   USUBJID = c(\"study123-123\", \"study123-124\", \"study123-125\"),   RFSTDTC = c(\"2012-02-01\", \"2012-04-14\", NA) ) ae$AESTDTC <- as.Date(ae$AESTDTC) dm$RFSTDTC <- as.Date(dm$RFSTDTC) derive_study_day(ae, dm, \"AESTDTC\", \"RFSTDTC\", \"AESTDY\") #>        USUBJID    AESTDTC AESTDY #> 1 study123-123 2012-01-01    -31 #> 2 study123-124 2012-04-14      1 #> 3 study123-125 2012-04-14     NA"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_formats.html","id":null,"dir":"Reference","previous_headings":"","what":"Date/time collection formats — dtc_formats","title":"Date/time collection formats — dtc_formats","text":"Date/time collection formats","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_formats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Date/time collection formats — dtc_formats","text":"","code":"dtc_formats"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_formats.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Date/time collection formats — dtc_formats","text":"tibble 20 formats three variables: fmt Format string. type Whether date, time date-time. description Description date-time components parsed.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_formats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Date/time collection formats — dtc_formats","text":"","code":"dtc_formats #> # A tibble: 20 × 3 #>    fmt         type     description                                              #>    <chr>       <chr>    <chr>                                                    #>  1 ymd         date     Parses a date: year, month, and month day.               #>  2 y m d       date     Parses a date: year, month, and month day.               #>  3 y-m-d       date     Parses a date: year, month, and month day.               #>  4 dmy         date     Parses a date: month day, month and year.                #>  5 d m y       date     Parses a date: month day, month and year.                #>  6 d-m-y       date     Parses a date: month day, month and year.                #>  7 ym          date     Parses a date: year and month.                           #>  8 y m         date     Parses a date: year and month.                           #>  9 y-m         date     Parses a date: year and month.                           #> 10 my          date     Parses a date: month and year.                           #> 11 m y         date     Parses a date: month and year.                           #> 12 m-y         date     Parses a date: month and year.                           #> 13 HM          time     Parses a time: hour and minutes.                         #> 14 HMS         time     Parses a time: hour, minutes, and seconds.               #> 15 H:M         time     Parses a time: hour and minutes.                         #> 16 H:M:S       time     Parses a time: hour, minutes and seconds.                #> 17 ymdH:M:S    datetime Parses a date-time: year, month, month day, hour, minut… #> 18 ymd H:M:S   datetime Parses a date-time: year, month, month day, hour, minut… #> 19 y-m-d H:M:S datetime Parses a date-time: year, month, month day, hour, minut… #> 20 y m d H:M:S datetime Parses a date-time: year, month, month day, hour, minut…"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dttm_fmt_to_regex.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","title":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","text":"dttm_fmt_to_regex() takes tibble parsed date/time format components (returned parse_dttm_fmt()), mapping date/time component formats regexps generates single regular expression groups matching date/time components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dttm_fmt_to_regex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","text":"","code":"dttm_fmt_to_regex(   fmt,   fmt_regex = fmt_rg(),   fmt_c = fmt_cmp(),   anchored = TRUE )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dttm_fmt_to_regex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","text":"fmt format string (scalar) parsed patterns. fmt_regex named character vector regexps, one date/time component. anchored Whether final regex anchored, .e. bounded \"^\" \"$\" whole match.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dttm_fmt_to_regex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","text":"string containing regular expression matching date/time components according format.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dttm_fmt_to_regex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","text":"","code":"sdtm.oak:::dttm_fmt_to_regex(\"y\") #> ^(?<year>(\\d{2})?\\d{2})$ sdtm.oak:::dttm_fmt_to_regex(\"y\", anchored = FALSE) #> [1] \"(?<year>(\\\\d{2})?\\\\d{2})\"  sdtm.oak:::dttm_fmt_to_regex(\"m\") #> ^(?<mon>\\d\\d|[Jj][Aa][Nn]|[Ff][Ee][Bb]|[Mm][Aa][Rr]|[Aa][Pp][Rr]|[Mm][Aa][Yy]|[Jj][Uu][Nn]|[Jj][Uu][Ll]|[Aa][Uu][Gg]|[Ss][Ee][Pp]|[Oo][Cc][Tt]|[Nn][Oo][Vv]|[Dd][Ee][Cc])$ sdtm.oak:::dttm_fmt_to_regex(\"ymd\") #> ^(?<year>(\\d{2})?\\d{2})(?<mon>\\d\\d|[Jj][Aa][Nn]|[Ff][Ee][Bb]|[Mm][Aa][Rr]|[Aa][Pp][Rr]|[Mm][Aa][Yy]|[Jj][Uu][Nn]|[Jj][Uu][Ll]|[Aa][Uu][Gg]|[Ss][Ee][Pp]|[Oo][Cc][Tt]|[Nn][Oo][Vv]|[Dd][Ee][Cc])(?<mday>\\b\\d|\\d{2})$  sdtm.oak:::dttm_fmt_to_regex(\"ymd HH:MM:SS\") #> ^(?<year>(\\d{2})?\\d{2})(?<mon>\\d\\d|[Jj][Aa][Nn]|[Ff][Ee][Bb]|[Mm][Aa][Rr]|[Aa][Pp][Rr]|[Mm][Aa][Yy]|[Jj][Uu][Nn]|[Jj][Uu][Ll]|[Aa][Uu][Gg]|[Ss][Ee][Pp]|[Oo][Cc][Tt]|[Nn][Oo][Vv]|[Dd][Ee][Cc])(?<mday>\\b\\d|\\d{2}) (?<hour>\\d?\\d):(?<min>(\\b\\d|\\d{2})):(?<sec>(\\b\\d|\\d{2})(\\.\\d*)?)$"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/find_int_gap.html","id":null,"dir":"Reference","previous_headings":"","what":"Find gap intervals in integer sequences — find_int_gap","title":"Find gap intervals in integer sequences — find_int_gap","text":"find_int_gap() determines start end positions gap intervals sequence integers. default, interval range look gaps defined minimum maximum values x; specify xmin xmax change range explicitly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/find_int_gap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find gap intervals in integer sequences — find_int_gap","text":"","code":"find_int_gap(x, xmin = min(x), xmax = max(x))"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/find_int_gap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find gap intervals in integer sequences — find_int_gap","text":"x integer vector. xmin Left endpoint integer value. xmax Right endpoint integer value.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/find_int_gap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find gap intervals in integer sequences — find_int_gap","text":"tibble gap intervals two columns: start: left endpoint end: right endpoint gap intervals found empty tibble returned.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":null,"dir":"Reference","previous_headings":"","what":"Regexps for date/time format components — fmt_cmp","title":"Regexps for date/time format components — fmt_cmp","text":"fmt_cmp() creates character vector patterns match individual format date/time components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regexps for date/time format components — fmt_cmp","text":"","code":"fmt_cmp(   sec = \"S+\",   min = \"M+\",   hour = \"H+\",   mday = \"d+\",   mon = \"m+\",   year = \"y+\" )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regexps for date/time format components — fmt_cmp","text":"sec string pattern matching second format component. min string pattern matching minute format component. hour string pattern matching hour format component. mday string pattern matching month day format component. mon string pattern matching month format component. year string pattern matching year format component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regexps for date/time format components — fmt_cmp","text":"named character vector date/time format patterns. vector six elements, one date/time component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regexps for date/time format components — fmt_cmp","text":"","code":"# Regexps to parse format components fmt_cmp() #> $sec #> [1] \"S+\" #>  #> $min #> [1] \"M+\" #>  #> $hour #> [1] \"H+\" #>  #> $mday #> [1] \"d+\" #>  #> $mon #> [1] \"m+\" #>  #> $year #> [1] \"y+\" #>  #> attr(,\"class\") #> [1] \"fmt_c\"  fmt_cmp(year = \"yyyy\") #> $sec #> [1] \"S+\" #>  #> $min #> [1] \"M+\" #>  #> $hour #> [1] \"H+\" #>  #> $mday #> [1] \"d+\" #>  #> $mon #> [1] \"m+\" #>  #> $year #> [1] \"yyyy\" #>  #> attr(,\"class\") #> [1] \"fmt_c\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_rg.html","id":null,"dir":"Reference","previous_headings":"","what":"Regexps for date/time components — fmt_rg","title":"Regexps for date/time components — fmt_rg","text":"fmt_rg() creates character vector named patterns match individual date/time components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_rg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regexps for date/time components — fmt_rg","text":"","code":"fmt_rg(   sec = \"(\\\\b\\\\d|\\\\d{2})(\\\\.\\\\d*)?\",   min = \"(\\\\b\\\\d|\\\\d{2})\",   hour = \"\\\\d?\\\\d\",   mday = \"\\\\b\\\\d|\\\\d{2}\",   mon = stringr::str_glue(\"\\\\d\\\\d|{months_abb_regex()}\"),   year = \"(\\\\d{2})?\\\\d{2}\",   na = NULL,   sec_na = na,   min_na = na,   hour_na = na,   mday_na = na,   mon_na = na,   year_na = na )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_rg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regexps for date/time components — fmt_rg","text":"sec Regexp second component. min Regexp minute component. hour Regexp hour component. mday Regexp month day component. mon Regexp month component. year Regexp year component. na Regexp alternatives, useful match special values coding missingness. sec_na na specifically second component. min_na na specifically minute component. hour_na na specifically hour component. mday_na na specifically month day component. mon_na na specifically month component. year_na na specifically year component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_rg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regexps for date/time components — fmt_rg","text":"named character vector named patterns (regexps) matching date/time component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_rg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regexps for date/time components — fmt_rg","text":"","code":"# Default regexps sdtm.oak:::fmt_rg() #>                                                                                                                                                                          sec  #>                                                                                                                                          \"(?<sec>(\\\\b\\\\d|\\\\d{2})(\\\\.\\\\d*)?)\"  #>                                                                                                                                                                          min  #>                                                                                                                                                    \"(?<min>(\\\\b\\\\d|\\\\d{2}))\"  #>                                                                                                                                                                         hour  #>                                                                                                                                                           \"(?<hour>\\\\d?\\\\d)\"  #>                                                                                                                                                                         mday  #>                                                                                                                                                     \"(?<mday>\\\\b\\\\d|\\\\d{2})\"  #>                                                                                                                                                                          mon  #> \"(?<mon>\\\\d\\\\d|[Jj][Aa][Nn]|[Ff][Ee][Bb]|[Mm][Aa][Rr]|[Aa][Pp][Rr]|[Mm][Aa][Yy]|[Jj][Uu][Nn]|[Jj][Uu][Ll]|[Aa][Uu][Gg]|[Ss][Ee][Pp]|[Oo][Cc][Tt]|[Nn][Oo][Vv]|[Dd][Ee][Cc])\"  #>                                                                                                                                                                         year  #>                                                                                                                                                   \"(?<year>(\\\\d{2})?\\\\d{2})\"   # You may change the way months are matched, e.g. you might not want to match # month abbreviations, i.e. only numerical months. So pass an explicit regex # for numerical months: sdtm.oak:::fmt_rg(mon = r\"[\\b\\d|\\d{2}]\") #>                                 sec                                 min  #> \"(?<sec>(\\\\b\\\\d|\\\\d{2})(\\\\.\\\\d*)?)\"           \"(?<min>(\\\\b\\\\d|\\\\d{2}))\"  #>                                hour                                mday  #>                  \"(?<hour>\\\\d?\\\\d)\"            \"(?<mday>\\\\b\\\\d|\\\\d{2})\"  #>                                 mon                                year  #>             \"(?<mon>\\\\b\\\\d|\\\\d{2})\"          \"(?<year>(\\\\d{2})?\\\\d{2})\"   # Make date/time components accept `\"UNK\"` as a possible pattern (useful # to match funny codes for `NA`). sdtm.oak:::fmt_rg(na = \"UNK\") #>                                                                                                                                                                              sec  #>                                                                                                                                          \"(?<sec>(\\\\b\\\\d|\\\\d{2})(\\\\.\\\\d*)?|UNK)\"  #>                                                                                                                                                                              min  #>                                                                                                                                                    \"(?<min>(\\\\b\\\\d|\\\\d{2})|UNK)\"  #>                                                                                                                                                                             hour  #>                                                                                                                                                           \"(?<hour>\\\\d?\\\\d|UNK)\"  #>                                                                                                                                                                             mday  #>                                                                                                                                                     \"(?<mday>\\\\b\\\\d|\\\\d{2}|UNK)\"  #>                                                                                                                                                                              mon  #> \"(?<mon>\\\\d\\\\d|[Jj][Aa][Nn]|[Ff][Ee][Bb]|[Mm][Aa][Rr]|[Aa][Pp][Rr]|[Mm][Aa][Yy]|[Jj][Uu][Nn]|[Jj][Uu][Ll]|[Aa][Uu][Gg]|[Ss][Ee][Pp]|[Oo][Cc][Tt]|[Nn][Oo][Vv]|[Dd][Ee][Cc]|UNK)\"  #>                                                                                                                                                                             year  #>                                                                                                                                                   \"(?<year>(\\\\d{2})?\\\\d{2}|UNK)\"   # Or be more specific and use `\"UNK\"` for the year component only. sdtm.oak:::fmt_rg(year_na = \"UNK\") #>                                                                                                                                                                          sec  #>                                                                                                                                          \"(?<sec>(\\\\b\\\\d|\\\\d{2})(\\\\.\\\\d*)?)\"  #>                                                                                                                                                                          min  #>                                                                                                                                                    \"(?<min>(\\\\b\\\\d|\\\\d{2}))\"  #>                                                                                                                                                                         hour  #>                                                                                                                                                           \"(?<hour>\\\\d?\\\\d)\"  #>                                                                                                                                                                         mday  #>                                                                                                                                                     \"(?<mday>\\\\b\\\\d|\\\\d{2})\"  #>                                                                                                                                                                          mon  #> \"(?<mon>\\\\d\\\\d|[Jj][Aa][Nn]|[Ff][Ee][Bb]|[Mm][Aa][Rr]|[Aa][Pp][Rr]|[Mm][Aa][Yy]|[Jj][Uu][Nn]|[Jj][Uu][Ll]|[Aa][Uu][Gg]|[Ss][Ee][Pp]|[Oo][Cc][Tt]|[Nn][Oo][Vv]|[Dd][Ee][Cc])\"  #>                                                                                                                                                                         year  #>                                                                                                                                               \"(?<year>(\\\\d{2})?\\\\d{2}|UNK)\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/format_iso8601.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert date/time components into ISO8601 format — format_iso8601","title":"Convert date/time components into ISO8601 format — format_iso8601","text":"format_iso8601() takes character matrix date/time components converts component ISO8601 format. practice entails converting years four digit number, month, day, hours, minutes seconds two-digit numbers. available (NA) components converted \"-\".","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/format_iso8601.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert date/time components into ISO8601 format — format_iso8601","text":"","code":"format_iso8601(m, .cutoff_2000 = 68L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/format_iso8601.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert date/time components into ISO8601 format — format_iso8601","text":"m character matrix date/time components. must six named columns: year, mon, mday, hour, min sec. .cutoff_2000 integer value. Two-digit years smaller equal .cutoff_2000 parsed though starting 20, otherwise parsed though starting 19.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/format_iso8601.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert date/time components into ISO8601 format — format_iso8601","text":"character vector date-times following ISO8601 format.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/format_iso8601.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert date/time components into ISO8601 format — format_iso8601","text":"","code":"cols <- c(\"year\", \"mon\", \"mday\", \"hour\", \"min\", \"sec\") m <- matrix(   c(     \"99\", \"00\", \"01\",     \"Jan\", \"feb\", \"03\",     \"1\", \"01\", \"31\",     \"00\", \"12\", \"23\",     \"00\", \"59\", \"10\",     \"42\", \"5.15\", NA   ),   ncol = 6,   dimnames = list(c(), cols) )  sdtm.oak:::format_iso8601(m) #> [1] \"1999-01-01T00:00:42\"    \"2000-02-01T12:59:05.15\" \"2001-03-31T23:10\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_mon.html","id":null,"dir":"Reference","previous_headings":"","what":"Format as a ISO8601 month — iso8601_mon","title":"Format as a ISO8601 month — iso8601_mon","text":"iso8601_mon() converts character vector whose values represent numeric abbreviated month names zero-padded numeric months.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_mon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format as a ISO8601 month — iso8601_mon","text":"","code":"iso8601_mon(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_mon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format as a ISO8601 month — iso8601_mon","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_mon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format as a ISO8601 month — iso8601_mon","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_mon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format as a ISO8601 month — iso8601_mon","text":"","code":"sdtm.oak:::iso8601_mon(c(NA, \"0\", \"1\", \"2\", \"10\", \"11\", \"12\")) #> [1] NA   \"00\" \"01\" \"02\" \"10\" \"11\" \"12\"  # No semantic validation is performed on the numeric months, so `\"13\"` stays # `\"13\"` but representations that can't be represented as two-digit numbers # become `NA`. sdtm.oak:::iso8601_mon(c(\"13\", \"99\", \"100\", \"-1\")) #> [1] \"13\" \"99\" NA   NA    (mon <- month.abb) #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\" sdtm.oak:::iso8601_mon(mon) #>  [1] \"01\" \"02\" \"03\" \"04\" \"05\" \"06\" \"07\" \"08\" \"09\" \"10\" \"11\" \"12\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert NA to ","title":"Convert NA to ","text":"iso8601_na() takes character vector converts NA values \"-\".","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert NA to ","text":"","code":"iso8601_na(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert NA to ","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert NA to ","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert NA to ","text":"","code":"sdtm.oak:::iso8601_na(c(\"10\", NA_character_)) #> [1] \"10\" \"-\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_sec.html","id":null,"dir":"Reference","previous_headings":"","what":"Format as ISO8601 seconds — iso8601_sec","title":"Format as ISO8601 seconds — iso8601_sec","text":"iso8601_sec() converts character vector whose values represent seconds.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_sec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format as ISO8601 seconds — iso8601_sec","text":"","code":"iso8601_sec(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_sec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format as ISO8601 seconds — iso8601_sec","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_sec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format as ISO8601 seconds — iso8601_sec","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_sec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format as ISO8601 seconds — iso8601_sec","text":"","code":"sdtm.oak:::iso8601_sec(c(NA, \"0\", \"1\", \"10\", \"59\", \"99\", \"100\")) #> [1] NA   \"00\" \"01\" \"10\" \"59\" \"99\" NA"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_truncate.html","id":null,"dir":"Reference","previous_headings":"","what":"Truncate a partial ISO8601 date-time — iso8601_truncate","title":"Truncate a partial ISO8601 date-time — iso8601_truncate","text":"iso8601_truncate() converts character vector ISO8601 dates, times date-times might partial truncates format removing missing components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_truncate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Truncate a partial ISO8601 date-time — iso8601_truncate","text":"","code":"iso8601_truncate(x, empty_as_na = TRUE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_truncate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Truncate a partial ISO8601 date-time — iso8601_truncate","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_truncate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Truncate a partial ISO8601 date-time — iso8601_truncate","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_truncate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Truncate a partial ISO8601 date-time — iso8601_truncate","text":"","code":"x <-   c(     \"1999-01-01T15:20:01\",     \"1999-01-01T15:20:-\",     \"1999-01-01T15:-:-\",     \"1999-01-01T-:-:-\",     \"1999-01--T-:-:-\",     \"1999----T-:-:-\",     \"-----T-:-:-\"   )  sdtm.oak:::iso8601_truncate(x) #> [1] \"1999-01-01T15:20:01\" \"1999-01-01T15:20\"    \"1999-01-01T15\"       #> [4] \"1999-01-01\"          \"1999-01\"             \"1999\"                #> [7] NA                     # With `empty_as_na = FALSE` empty strings are not replaced with `NA` sdtm.oak:::iso8601_truncate(\"-----T-:-:-\", empty_as_na = TRUE) #> [1] NA sdtm.oak:::iso8601_truncate(\"-----T-:-:-\", empty_as_na = FALSE) #> [1] \"\"  # Truncation only happens if missing components are the right most end, # otherwise they remain unaltered. sdtm.oak:::iso8601_truncate(   c(     \"1999----T15:20:01\",     \"1999-01-01T-:20:01\",     \"1999-01-01T-:-:01\",     \"1999-01-01T-:-:-\"   ) ) #> [1] \"1999----T15:20:01\"  \"1999-01-01T-:20:01\" \"1999-01-01T-:-:01\"  #> [4] \"1999-01-01\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_two_digits.html","id":null,"dir":"Reference","previous_headings":"","what":"Format as a ISO8601 two-digit number — iso8601_two_digits","title":"Format as a ISO8601 two-digit number — iso8601_two_digits","text":"iso8601_two_digits() converts single digit two digit number two digit, 0-padded, number. Failing parse input two digit number results NA.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_two_digits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format as a ISO8601 two-digit number — iso8601_two_digits","text":"","code":"iso8601_two_digits(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_two_digits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format as a ISO8601 two-digit number — iso8601_two_digits","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_two_digits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format as a ISO8601 two-digit number — iso8601_two_digits","text":"character vector size x.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_two_digits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format as a ISO8601 two-digit number — iso8601_two_digits","text":"","code":"x <- c(\"0\", \"00\", \"1\", \"01\", \"42\", \"100\", NA_character_, \"1.\") sdtm.oak:::iso8601_two_digits(x) #> [1] \"00\" \"00\" \"01\" \"01\" \"42\" NA   NA   NA"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_year.html","id":null,"dir":"Reference","previous_headings":"","what":"Format as a ISO8601 four-digit year — iso8601_year","title":"Format as a ISO8601 four-digit year — iso8601_year","text":"iso8601_year() converts character vector whose values represent years four-digit years.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_year.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format as a ISO8601 four-digit year — iso8601_year","text":"","code":"iso8601_year(x, cutoff_2000 = 68L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_year.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format as a ISO8601 four-digit year — iso8601_year","text":"x character vector. cutoff_2000 non-negative integer value. Two-digit years smaller equal cutoff_2000 parsed though starting 20, otherwise parsed though starting 19.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_year.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format as a ISO8601 four-digit year — iso8601_year","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_year.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format as a ISO8601 four-digit year — iso8601_year","text":"","code":"sdtm.oak:::iso8601_year(c(\"0\", \"1\", \"2\", \"50\", \"68\", \"69\", \"90\", \"99\", \"00\")) #> [1] \"2000\" \"2001\" \"2002\" \"2050\" \"2068\" \"1969\" \"1990\" \"1999\" \"2000\"  # Be default, `cutoff_2000` is at 68. sdtm.oak:::iso8601_year(c(\"67\", \"68\", \"69\", \"70\")) #> [1] \"2067\" \"2068\" \"1969\" \"1970\" sdtm.oak:::iso8601_year(c(\"1967\", \"1968\", \"1969\", \"1970\")) #> [1] \"1967\" \"1968\" \"1969\" \"1970\"  # Change it to something else, e.g. `cutoff_2000 = 25`. sdtm.oak:::iso8601_year(as.character(0:50), cutoff_2000 = 25) #>  [1] \"2000\" \"2001\" \"2002\" \"2003\" \"2004\" \"2005\" \"2006\" \"2007\" \"2008\" \"2009\" #> [11] \"2010\" \"2011\" \"2012\" \"2013\" \"2014\" \"2015\" \"2016\" \"2017\" \"2018\" \"2019\" #> [21] \"2020\" \"2021\" \"2022\" \"2023\" \"2024\" \"2025\" \"1926\" \"1927\" \"1928\" \"1929\" #> [31] \"1930\" \"1931\" \"1932\" \"1933\" \"1934\" \"1935\" \"1936\" \"1937\" \"1938\" \"1939\" #> [41] \"1940\" \"1941\" \"1942\" \"1943\" \"1944\" \"1945\" \"1946\" \"1947\" \"1948\" \"1949\" #> [51] \"1950\" sdtm.oak:::iso8601_year(as.character(1900:1950), cutoff_2000 = 25) #>  [1] \"1900\" \"1901\" \"1902\" \"1903\" \"1904\" \"1905\" \"1906\" \"1907\" \"1908\" \"1909\" #> [11] \"1910\" \"1911\" \"1912\" \"1913\" \"1914\" \"1915\" \"1916\" \"1917\" \"1918\" \"1919\" #> [21] \"1920\" \"1921\" \"1922\" \"1923\" \"1924\" \"1925\" \"1926\" \"1927\" \"1928\" \"1929\" #> [31] \"1930\" \"1931\" \"1932\" \"1933\" \"1934\" \"1935\" \"1936\" \"1937\" \"1938\" \"1939\" #> [41] \"1940\" \"1941\" \"1942\" \"1943\" \"1944\" \"1945\" \"1946\" \"1947\" \"1948\" \"1949\" #> [51] \"1950\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/months_abb_regex.html","id":null,"dir":"Reference","previous_headings":"","what":"Regex for months' abbreviations — months_abb_regex","title":"Regex for months' abbreviations — months_abb_regex","text":"months_abb_regex() generates regex matches month abbreviations. finer control, case can specified parameter case.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/months_abb_regex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regex for months' abbreviations — months_abb_regex","text":"","code":"months_abb_regex(x = month.abb, case = c(\"any\", \"upper\", \"lower\", \"title\"))"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/months_abb_regex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regex for months' abbreviations — months_abb_regex","text":"x character vector three-letter month abbreviations. Default month.abb. case string scalar: \"\", month abbreviations matched case; \"upper\", match uppercase abbreviations; \"lower\", match lowercase; , \"title\" match title case.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/months_abb_regex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regex for months' abbreviations — months_abb_regex","text":"regex string.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a date, time, or date-time — parse_dttm_","title":"Parse a date, time, or date-time — parse_dttm_","text":"parse_dttm() extracts date time components. parse_dttm() wraps around parse_dttm_(), vectorized fmt.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a date, time, or date-time — parse_dttm_","text":"","code":"parse_dttm_(   dttm,   fmt,   fmt_c = fmt_cmp(),   na = NULL,   sec_na = na,   min_na = na,   hour_na = na,   mday_na = na,   mon_na = na,   year_na = na )  parse_dttm(   dttm,   fmt,   fmt_c = fmt_cmp(),   na = NULL,   sec_na = na,   min_na = na,   hour_na = na,   mday_na = na,   mon_na = na,   year_na = na )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a date, time, or date-time — parse_dttm_","text":"dttm character vector dates, times date-times. fmt case parse_dttm(), character vector parsing formats, single string format case parse_dttm_(). character vector formats passed, format attempted turn first parsing result successful taking precedence final result. formats fmt can strings, however following characters (successive repetitions thereof) reserved sense treated special way: \"y\": parsed year; \"m\": parsed month; \"d\": parsed day; \"H\": parsed hour; \"M\": parsed minute; \"S\": parsed second. na, sec_na, min_na, hour_na, mday_na, mon_na, year_na character vector alternative values allow matching. can used indicate different forms missing values found parsing date-time strings.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a date, time, or date-time — parse_dttm_","text":"character matrix six columns: \"year\", \"mon\", \"mday\", \"hour\", \"min\" \"sec\". row corresponds element dttm. element matrix parsed date/time component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse a date, time, or date-time — parse_dttm_","text":"","code":"sdtm.oak:::parse_dttm(\"2020\", \"y\") #>      year   mon mday hour min sec #> [1,] \"2020\" NA  NA   NA   NA  NA  sdtm.oak:::parse_dttm(\"2020-05\", \"y\") #>      year mon mday hour min sec #> [1,] NA   NA  NA   NA   NA  NA   sdtm.oak:::parse_dttm(\"2020-05\", \"y-m\") #>      year   mon  mday hour min sec #> [1,] \"2020\" \"05\" NA   NA   NA  NA  sdtm.oak:::parse_dttm(\"2020-05-11\", \"y-m-d\") #>      year   mon  mday hour min sec #> [1,] \"2020\" \"05\" \"11\" NA   NA  NA   sdtm.oak:::parse_dttm(\"2020 05 11\", \"y m d\") #>      year   mon  mday hour min sec #> [1,] \"2020\" \"05\" \"11\" NA   NA  NA  sdtm.oak:::parse_dttm(\"2020  05  11\", \"y m d\") #>      year mon mday hour min sec #> [1,] NA   NA  NA   NA   NA  NA  sdtm.oak:::parse_dttm(\"2020  05  11\", \"y\\\\s+m\\\\s+d\") #>      year   mon  mday hour min sec #> [1,] \"2020\" \"05\" \"11\" NA   NA  NA  sdtm.oak:::parse_dttm(\"2020      05     11\", \"y\\\\s+m\\\\s+d\") #>      year   mon  mday hour min sec #> [1,] \"2020\" \"05\" \"11\" NA   NA  NA   sdtm.oak:::parse_dttm(\"2020-05-11 11:45\", \"y-m-d H:M\") #>      year   mon  mday hour min  sec #> [1,] \"2020\" \"05\" \"11\" \"11\" \"45\" NA  sdtm.oak:::parse_dttm(\"2020-05-11 11:45:15.6\", \"y-m-d H:M:S\") #>      year   mon  mday hour min  sec    #> [1,] \"2020\" \"05\" \"11\" \"11\" \"45\" \"15.6\"  sdtm.oak:::parse_dttm(c(\"2002-05-11 11:45\", \"-05-11 11:45\"), \"y-m-d H:M\") #>      year   mon  mday hour min  sec #> [1,] \"2002\" \"05\" \"11\" \"11\" \"45\" NA  #> [2,] NA     NA   NA   NA   NA   NA  sdtm.oak:::parse_dttm(c(\"2002-05-11 11:45\", \"-05-11 11:45\"), \"-m-d H:M\") #>      year mon  mday hour min  sec #> [1,] NA   NA   NA   NA   NA   NA  #> [2,] NA   \"05\" \"11\" \"11\" \"45\" NA  sdtm.oak:::parse_dttm(c(\"2002-05-11 11:45\", \"-05-11 11:45\"), c(\"y-m-d H:M\", \"-m-d H:M\")) #>      year   mon  mday hour min  sec #> [1,] \"2002\" \"05\" \"11\" \"11\" \"45\" NA  #> [2,] NA     \"05\" \"11\" \"11\" \"45\" NA   sdtm.oak:::parse_dttm(\"05 feb 1985 12 55 02\", \"d m y H M S\") #>      year   mon   mday hour min  sec  #> [1,] \"1985\" \"feb\" \"05\" \"12\" \"55\" \"02\" sdtm.oak:::parse_dttm(\"12 55 02 05 feb 1985\", \"H M S d m y\") #>      year   mon   mday hour min  sec  #> [1,] \"1985\" \"feb\" \"05\" \"12\" \"55\" \"02\"  sdtm.oak:::parse_dttm(c(\"2020-05-18\", \"2020-UN-18\", \"2020-UNK-UN\"), \"y-m-d\") #>      year   mon  mday hour min sec #> [1,] \"2020\" \"05\" \"18\" NA   NA  NA  #> [2,] NA     NA   NA   NA   NA  NA  #> [3,] NA     NA   NA   NA   NA  NA  sdtm.oak:::parse_dttm(c(\"2020-05-18\", \"2020-UN-18\", \"2020-UNK-UN\"), \"y-m-d\", na = \"UN\") #>      year   mon  mday hour min sec #> [1,] \"2020\" \"05\" \"18\" NA   NA  NA  #> [2,] \"2020\" \"UN\" \"18\" NA   NA  NA  #> [3,] NA     NA   NA   NA   NA  NA  sdtm.oak:::parse_dttm(c(\"2020-05-18\", \"2020-UN-18\", \"2020-UNK-UN\"), \"y-m-d\", na = c(\"UN\", \"UNK\")) #>      year   mon   mday hour min sec #> [1,] \"2020\" \"05\"  \"18\" NA   NA  NA  #> [2,] \"2020\" \"UN\"  \"18\" NA   NA  NA  #> [3,] \"2020\" \"UNK\" \"UN\" NA   NA  NA"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm_fmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a date/time format — parse_dttm_fmt_","title":"Parse a date/time format — parse_dttm_fmt_","text":"parse_dttm_fmt() parses date/time formats, meaning try parse components format fmt refer date/time components. parse_dttm_fmt_() similar parse_dttm_fmt() vectorized fmt.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm_fmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a date/time format — parse_dttm_fmt_","text":"","code":"parse_dttm_fmt_(fmt, pattern)  parse_dttm_fmt(fmt, patterns = fmt_cmp())"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm_fmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a date/time format — parse_dttm_fmt_","text":"fmt format string (scalar) parsed patterns. pattern, patterns string (case pattern), character vector (case patterns) regexps individual date/time components. Default value fmt_cmp(). Use function plan passing different set patterns.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm_fmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a date/time format — parse_dttm_fmt_","text":"tibble seven columns: fmt_c: date/time format component. Values either \"year\", \"mon\", \"mday\", \"hour\", \"min\", \"sec\", NA. pat: Regexp used parse date/time component. cap: captured substring format. start: Start position format string capture. end: End position format string capture. len: Length capture (number chars). ord: Ordinal date/time component format string. row either date/time format component \"delimiter\" string pattern -format components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm_fmt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse a date/time format — parse_dttm_fmt_","text":"","code":"sdtm.oak:::parse_dttm_fmt(\"ymd\") #> # A tibble: 3 × 7 #>   fmt_c pat   cap   start   end   len   ord #>   <chr> <chr> <chr> <int> <int> <int> <int> #> 1 year  y+    y         1     1     1     1 #> 2 mon   m+    m         2     2     1     2 #> 3 mday  d+    d         3     3     1     3 sdtm.oak:::parse_dttm_fmt(\"H:M:S\") #> # A tibble: 5 × 7 #>   fmt_c pat   cap   start   end   len   ord #>   <chr> <chr> <chr> <int> <int> <int> <int> #> 1 hour  H+    H         1     1     1     1 #> 2 NA    NA    :         2     2     1    NA #> 3 min   M+    M         3     3     1     2 #> 4 NA    NA    :         4     4     1    NA #> 5 sec   S+    S         5     5     1     3  sdtm.oak:::parse_dttm_fmt(\"ymd HMS\") #> # A tibble: 7 × 7 #>   fmt_c pat   cap   start   end   len   ord #>   <chr> <chr> <chr> <int> <int> <int> <int> #> 1 year  y+    \"y\"       1     1     1     1 #> 2 mon   m+    \"m\"       2     2     1     2 #> 3 mday  d+    \"d\"       3     3     1     3 #> 4 NA    NA    \" \"       4     4     1    NA #> 5 hour  H+    \"H\"       5     5     1     4 #> 6 min   M+    \"M\"       6     6     1     5 #> 7 sec   S+    \"S\"       7     7     1     6  # Repeating the same special patterns, e.g. \"yy\" still counts as one pattern # only. sdtm.oak:::parse_dttm_fmt(\"yymmdd HHMMSS\") #> # A tibble: 7 × 7 #>   fmt_c pat   cap   start   end   len   ord #>   <chr> <chr> <chr> <int> <int> <int> <int> #> 1 year  y+    \"yy\"      1     2     2     1 #> 2 mon   m+    \"mm\"      3     4     2     2 #> 3 mday  d+    \"dd\"      5     6     2     3 #> 4 NA    NA    \" \"       7     7     1    NA #> 5 hour  H+    \"HH\"      8     9     2     4 #> 6 min   M+    \"MM\"     10    11     2     5 #> 7 sec   S+    \"SS\"     12    13     2     6  # Note that `\"y\"`, `\"m\"`, `\"d\"`, `\"H\"`, `\"M\"` or `\"S\"` are reserved patterns # that are matched first and interpreted as format components. # Example: the # first \"y\" in \"year\" is parsed as meaning year followed by \"ear y\". The # second \"y\" is not longer matched because a first match already # succeded. sdtm.oak:::parse_dttm_fmt(\"year y\") #> # A tibble: 2 × 7 #>   fmt_c pat   cap   start   end   len   ord #>   <chr> <chr> <chr> <int> <int> <int> <int> #> 1 year  y+    y         1     1     1     1 #> 2 NA    NA    ear y     2     6     5    NA  # Specify custom patterns sdtm.oak:::parse_dttm_fmt(   \"year month day\",   fmt_cmp(year = \"year\", mon = \"month\", mday = \"day\") ) #> # A tibble: 5 × 7 #>   fmt_c pat   cap     start   end   len   ord #>   <chr> <chr> <chr>   <int> <int> <int> <int> #> 1 year  year  \"year\"      1     4     4     1 #> 2 NA    NA    \" \"         5     5     1    NA #> 3 mon   month \"month\"     6    10     5     2 #> 4 NA    NA    \" \"        11    11     1    NA #> 5 mday  day   \"day\"      12    14     3     3"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve date/time parsing problems — problems","title":"Retrieve date/time parsing problems — problems","text":"problems() companion helper function create_iso8601(). retrieves ISO 8601 parsing problems object class iso8601, create_iso8601()'s return value might contain problems attribute case parsing failures. problems() helper function provides easy access parsing problems.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve date/time parsing problems — problems","text":"","code":"problems(x = .Last.value)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve date/time parsing problems — problems","text":"x object class iso8601, typically obtained call create_iso8601(). argument can also left empty, case problems() use last returned value, making convenient use immediately create_iso8601().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve date/time parsing problems — problems","text":"parsing problems x, returned value NULL; otherwise, tibble parsing failures returned. row corresponds parsing problem. first column named ..indicating position(s) inputs create_iso8601() call resulted failures; remaining columns correspond original input values passed create_iso8601(), columns automatically named ..var1, ..var2, , inputs create_iso8601() unnamed, otherwise, original variable names used instead.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve date/time parsing problems — problems","text":"","code":"dates <-   c(     \"2020-01-01\",     \"2020-02-11\",     \"2020-01-06\",     \"2020-0921\",     \"2020/10/30\",     \"2020-12-05\",     \"20231225\"   )  #' # By inspecting the problematic dates it can be understood that # the `.format` parameter needs to updated to include other variations. iso8601_dttm <- create_iso8601(dates, .format = \"y-m-d\") problems(iso8601_dttm) #> # A tibble: 3 × 2 #>     ..i ..var1     #>   <int> <chr>      #> 1     4 2020-0921  #> 2     5 2020/10/30 #> 3     7 20231225    # Including more parsing formats addresses the previous problems formats <- c(\"y-m-d\", \"y-md\", \"y/m/d\", \"ymd\") iso8601_dttm2 <- create_iso8601(dates, .format = list(formats))  # So now `problems()` returns `NULL` because there are no more parsing issues. problems(iso8601_dttm2)  # If you pass named arguments when calling `create_iso8601()` then they will # be used to create the problems object. iso8601_dttm3 <- create_iso8601(date = dates, .format = \"y-m-d\") problems(iso8601_dttm3) #> # A tibble: 3 × 2 #>     ..i date       #>   <int> <chr>      #> 1     4 2020-0921  #> 2     5 2020/10/30 #> 3     7 20231225"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/pseq.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallel sequence generation — pseq","title":"Parallel sequence generation — pseq","text":"pseq() similar seq() conveniently accepts integer vectors inputs , allowing parallel generation sequences. result union generated sequences.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/pseq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallel sequence generation — pseq","text":"","code":"pseq(from, to)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/pseq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallel sequence generation — pseq","text":"integer vector. starting value(s) sequence(s). integer vector. ending value(s) sequence(s).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/pseq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallel sequence generation — pseq","text":"integer vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/reg_matches.html","id":null,"dir":"Reference","previous_headings":"","what":"regmatches() with NA — reg_matches","title":"regmatches() with NA — reg_matches","text":"reg_matches() thin wrapper around regmatches() returns NA instead character(0) matching fails.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/reg_matches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"regmatches() with NA — reg_matches","text":"","code":"reg_matches(x, m, invert = FALSE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/reg_matches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"regmatches() with NA — reg_matches","text":"x character vector. m object match data. invert logical scalar. TRUE, extract replace non-matched substrings.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/reg_matches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"regmatches() with NA — reg_matches","text":"list character vectors matched substrings, NA matching failed.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/regex_or.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility function to assemble a regex of alternative patterns — regex_or","title":"Utility function to assemble a regex of alternative patterns — regex_or","text":"regex_or() takes set patterns binds (\"|\") pattern easy regex alternative patterns.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/regex_or.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility function to assemble a regex of alternative patterns — regex_or","text":"","code":"regex_or(x, .open = FALSE, .close = FALSE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/regex_or.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility function to assemble a regex of alternative patterns — regex_or","text":"x character vector alternative patterns. .open Whether resulting regex start \"|\". .close Whether resulting regex end \"|\".","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/regex_or.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility function to assemble a regex of alternative patterns — regex_or","text":"character scalar resulting regex.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/regex_or.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility function to assemble a regex of alternative patterns — regex_or","text":"","code":"# A regex for matching either \"jan\" or \"feb\" sdtm.oak:::regex_or(c(\"jan\", \"feb\")) #> [1] \"jan|feb\"  # Setting `.open` and/or `.close` to `TRUE` can be handy if this regex # is to be combined into a larger regex. paste0(sdtm.oak:::regex_or(c(\"jan\", \"feb\"), .close = TRUE), r\"{\\d{2}}\") #> [1] \"jan|feb|\\\\d{2}\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm.oak-package.html","id":null,"dir":"Reference","previous_headings":"","what":"sdtm.oak: SDTM Data Transformation Engine — sdtm.oak-package","title":"sdtm.oak: SDTM Data Transformation Engine — sdtm.oak-package","text":"EDC Data Standard-agnostic SDTM data transformation engine designed SDTM programming R. Powered metadata sdtm.oak can automate conversion raw clinical data SDTM standardized mapping algorithms. SDTM one required standards data submission FDA (U.S.) PMDA (Japan). SDTM standards implemented accordance SDTM Implementation Guide defined CDISC https://www.cdisc.org/standards/foundational/sdtmig.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm.oak-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"sdtm.oak: SDTM Data Transformation Engine — sdtm.oak-package","text":"Maintainer: Rammprasad Ganapathy ganapathy.rammprasad@gene.com Authors: Adam Forys Edgar Manukyan Rosemary Li Preetesh Parikh Lisa Houterloot Yogesh Gupta Omar Garcia ogcalderon@cdisc.org Ramiro Magno rmagno@pattern.institute (ORCID) contributors: Pattern Institute [copyright holder, funder] F. Hoffmann-La Roche AG [copyright holder, funder] Pfizer Inc [copyright holder, funder]","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/str_to_anycase.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate case insensitive regexps — str_to_anycase","title":"Generate case insensitive regexps — str_to_anycase","text":"str_to_anycase() takes character vector word strings input, generates regular expressions express match case.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/str_to_anycase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate case insensitive regexps — str_to_anycase","text":"","code":"str_to_anycase(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/str_to_anycase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate case insensitive regexps — str_to_anycase","text":"x character vector strings consisting word characters.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/str_to_anycase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate case insensitive regexps — str_to_anycase","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/yy_to_yyyy.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert two-digit to four-digit years — yy_to_yyyy","title":"Convert two-digit to four-digit years — yy_to_yyyy","text":"yy_to_yyyy() converts two-digit years four-digit years.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/yy_to_yyyy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert two-digit to four-digit years — yy_to_yyyy","text":"","code":"yy_to_yyyy(x, cutoff_2000 = 68L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/yy_to_yyyy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert two-digit to four-digit years — yy_to_yyyy","text":"x integer vector years. cutoff_2000 integer value. Two-digit years smaller equal cutoff_2000 parsed though starting 20, otherwise parsed though starting 19.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/yy_to_yyyy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert two-digit to four-digit years — yy_to_yyyy","text":"integer vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/yy_to_yyyy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert two-digit to four-digit years — yy_to_yyyy","text":"","code":"sdtm.oak:::yy_to_yyyy(0:5) #> [1] 2000 2001 2002 2003 2004 2005 sdtm.oak:::yy_to_yyyy(2000:2005) #> [1] 2000 2001 2002 2003 2004 2005  sdtm.oak:::yy_to_yyyy(90:99) #>  [1] 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 sdtm.oak:::yy_to_yyyy(1990:1999) #>  [1] 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999  # NB: change in behavior after 68 sdtm.oak:::yy_to_yyyy(65:72) #> [1] 2065 2066 2067 2068 1969 1970 1971 1972  sdtm.oak:::yy_to_yyyy(1965:1972) #> [1] 1965 1966 1967 1968 1969 1970 1971 1972"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/zero_pad_whole_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","title":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","text":"zero_pad_whole_number() takes non-negative integer values converts character zero padding. Negative numbers numbers greater width specified number digits n converted NA.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/zero_pad_whole_number.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","text":"","code":"zero_pad_whole_number(x, n = 2L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/zero_pad_whole_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","text":"x integer vector. n Number digits output, including zero padding.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/zero_pad_whole_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/zero_pad_whole_number.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","text":"","code":"sdtm.oak:::zero_pad_whole_number(c(-1, 0, 1)) #> [1] NA   \"00\" \"01\"  sdtm.oak:::zero_pad_whole_number(c(-1, 0, 1, 10, 99, 100), n = 2) #> [1] NA   \"00\" \"01\" \"10\" \"99\" NA    sdtm.oak:::zero_pad_whole_number(c(-1, 0, 1, 10, 99, 100), n = 3) #> [1] NA    \"000\" \"001\" \"010\" \"099\" \"100\""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/news/index.html","id":"new-features-0-0-0-9001","dir":"Changelog","previous_headings":"","what":"New Features","title":"sdtm.oak 0.0.0.9001 (development version)","text":"New function create_iso8601() conversion vectors dates, times date-times ISO8601 format.","code":""}]
